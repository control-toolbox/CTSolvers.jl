var documenterSearchIndex = {"docs":
[{"location":"manual-initial-guess.html#Initial-guesses","page":"Initial guesses","title":"Initial guesses","text":"This page describes how to provide initial guesses for optimal control problems in CTSolvers. It mirrors the structure of the general initial‚Äëguess manual in OptimalControl.jl, but focuses on the interfaces exposed by CTSolvers, including the @init macro.\n\nWe assume throughout that you have already defined an optimal control problem ocp using CTParser.@def.\n\nusing CTParser, CTSolvers\n\nocp = @def begin\n    t ‚àà [0, 1], time\n    x = (q, v) ‚àà R¬≤, state\n    u ‚àà R, control\n    x(0) == [-1, 0]\n    x(1) == [0, 0]\n    xÃá(t) == [v(t), u(t)]\n    ‚à´(0.5u(t)^2) ‚Üí min\nend\n\nThe goal is to build an OptimalControlInitialGuess compatible with this problem, either explicitly or indirectly.\n\n","category":"section"},{"location":"manual-initial-guess.html#High‚Äëlevel-entry-points","page":"Initial guesses","title":"High‚Äëlevel entry points","text":"There are two main entry points for users:\n\ninitial_guess(ocp; state=..., control=..., variable=...)\nbuild_initial_guess(ocp, init_data)\n\nThe first is a convenience keyword API. The second is a generic builder that accepts several different types of init_data.","category":"section"},{"location":"manual-initial-guess.html#initial_guess-keyword-API","page":"Initial guesses","title":"initial_guess keyword API","text":"ig = CTSolvers.initial_guess(ocp; state=0.0, control=0.1)\n\nThe keyword arguments may be:\n\nconstants (scalars or vectors) with dimensions consistent with the problem,\nfunctions of time t -> x(t) or t -> u(t),\nnothing (use internal defaults).\n\nThe state and control are interpreted using initial_state and initial_control helpers, and initial_guess always returns a validated OptimalControlInitialGuess.","category":"section"},{"location":"manual-initial-guess.html#build_initial_guess(ocp,-init_data)","page":"Initial guesses","title":"build_initial_guess(ocp, init_data)","text":"build_initial_guess is more general and dispatches on the type of init_data:\n\nig = CTSolvers.build_initial_guess(ocp, init_data)\n\nSupported forms include:\n\nnothing or () ‚Üí default initial guess.\nan OptimalControlInitialGuess instance ‚Üí returned as is.\nan OptimalControlPreInit (from pre_initial_guess) ‚Üí completed and validated.\na CTModels.AbstractSolution ‚Üí warm‚Äëstart from an existing solution.\na NamedTuple ‚Üí flexible block / component specification (see below).\n\nIn all cases, the result is validated against the problem dimensions and time settings.\n\n","category":"section"},{"location":"manual-initial-guess.html#Warm‚Äëstarting-from-an-existing-solution","page":"Initial guesses","title":"Warm‚Äëstarting from an existing solution","text":"If you already have a solution sol of a related problem (for example after a previous solve), you can use it directly as an initial guess:\n\nusing CTModels\n\nsol = \"some CTModels.AbstractSolution\"  # for illustration\nig = CTSolvers.build_initial_guess(ocp, sol)\n\nThis extracts state(sol), control(sol) and variable(sol) and wraps them in an OptimalControlInitialGuess, performing consistency checks on state, control and variable dimensions.\n\n","category":"section"},{"location":"manual-initial-guess.html#NamedTuple-initial-guesses","page":"Initial guesses","title":"NamedTuple initial guesses","text":"The most flexible non‚Äëmacro interface is to pass a NamedTuple with block and component entries. The allowed keys are:\n\nglobal blocks: :state, :control, :variable,\naliases based on the OCP names: Symbol(state_name(ocp)), Symbol(control_name(ocp)), Symbol(variable_name(ocp)),\ncomponent names of state, control and variable (e.g. :q, :v, :u1, :tf).\n\nExample for the simple fixed‚Äëhorizon problem above:\n\ninit_nt = (\n    q = t -> sin(t),\n    v = t -> 1.0,\n    u = t -> t,\n)\nig = CTSolvers.build_initial_guess(ocp, init_nt)\n\nBlock‚Äëlevel initialisation is also supported:\n\ninit_nt = (\n    x = t -> [sin(t), 1.0],  # whole state block\n    u = t -> t,\n)\nig = CTSolvers.build_initial_guess(ocp, init_nt)\n\nTime‚Äëgrid based initial guesses are expressed as (time, data) tuples:\n\nT = [0.0, 0.5, 1.0]\nX = [[-1.0, 0.0], [0.0, 0.5], [0.0, 0.0]]\nU = [0.0, 0.0, 1.0]\n\ninit_nt = (\n    x = (T, X),\n    u = (T, U),\n)\nig = CTSolvers.build_initial_guess(ocp, init_nt)\n``+\n\nComponent‚Äëwise time grids are supported in the same way by using component\nnames (`:q`, `:v`, `:u1`, ‚Ä¶) as keys.\n\nAll these forms are exercised and checked in\n`test/ctmodels/test_ctmodels_initial_guess.jl`.\n\n---\n\n## The `@init` macro\n\nWriting large `NamedTuple` literals can be verbose. CTSolvers provides a macro\n`@init` that offers a small DSL and compiles directly to a validated\n`OptimalControlInitialGuess`.\n\n### Basic usage\n\nThe general form is:\n\n\njulia ig = @init ocp begin     # alias statements     a = 1.0\n\n# time‚Äëdependent component\nq(t) := sin(t)\n\n# time‚Äëdependent block\nx(t) := [sin(t), 1.0]\n\n# time‚Äëgrid based init\nx(T) := X\nu(T) := U\n\n# constant / variable init\nu := 0.1\n\nend\n\n\nThe macro returns an `OptimalControlInitialGuess` and internally performs:\n\n1. Expansion of the DSL into a `NamedTuple` specification.\n2. A call to `build_initial_guess(ocp, namedtuple)`.\n3. A call to `validate_initial_guess(ocp, ig)`.\n\nYou can therefore pass the result directly to `CommonSolve.solve` or to any\nother code that expects an `AbstractOptimalControlInitialGuess`.\n\n### Accepted DSL forms\n\nInside the `begin ‚Ä¶ end` block, the macro recognises four kinds of lines:\n\n1. **Aliases** (ordinary Julia assignments)\n\n   ```julia\n   a = 1.0\n   something = sin\n   ```\n\n   These are left untouched and can be used in the right‚Äëhand sides of other\n   specifications.\n\n2. **Time‚Äëdependent functions**\n\n   ```julia\n   q(t) := sin(t)\n   x(t) := [sin(t), 1.0]\n   u(t) := t\n   ```\n\n   The macro converts `lhs(t) := rhs` into a function `t -> rhs` and associates\n   it with the key `:lhs` (either a component or a block).\n\n3. **Time‚Äëgrid based initialisation**\n\n   ```julia\n   x(T) := X\n   u(T) := U\n   q(Tq) := Dq\n   ```\n\n   The macro converts `lhs(T) := rhs` into `(T, rhs)` and associates it with the\n   key `:lhs`. This is exactly the same structure as the `(time, data)` tuples\n   accepted by the `NamedTuple` interface.\n\n4. **Constant / variable form**\n\n   ```julia\n   q := -1.0\n   v := 0.0\n   u := 0.1\n   tf := 1.0\n   ```\n\n   These are treated as constant initial values for the corresponding block or\n   component.\n\n### Relation to the NamedTuple form\n\nFor a fixed‚Äëhorizon problem, the following macro call:\n\n\njulia ig = @init ocp begin     q(t) := sin(t)     v(t) := 1.0     u(t) := t end\n\n\nis equivalent (up to validation) to\n\n\njulia initnt = (     q = t -> sin(t),     v = t -> 1.0,     u = t -> t, ) ig = CTSolvers.buildinitialguess(ocp, initnt)\n\n\nSimilarly, a block‚Äëlevel specification\n\n\njulia ig = @init ocp begin     x(t) := [sin(t), 1.0]     u(t) := t end\n\n\ncorresponds to\n\n\njulia initnt = (     x = t -> [sin(t), 1.0],     u = t -> t, ) ig = CTSolvers.buildinitialguess(ocp, initnt)\n\n\nTime‚Äëgrid based specifications follow the same pattern:\n\n\njulia T = [0.0, 0.5, 1.0] X = [[-1.0, 0.0], [0.0, 0.5], [0.0, 0.0]] U = [0.0, 0.0, 1.0]\n\nig = @init ocp begin     x(T) := X     u(T) := U end\n\n\nis equivalent to\n\n\njulia initnt = (     x = (T, X),     u = (T, U), ) ig = CTSolvers.buildinitialguess(ocp, initnt)\n\n\n### Logging the expanded initial guess\n\nFor debugging, `@init` supports an optional keyword‚Äëlike argument\n`log = true` that prints a compact representation of the underlying\n`NamedTuple` specification before building the initial guess:\n\n\njulia ig = @init ocp begin     q(t) := sin(t)     v(t) := 1.0     u(t) := t end log = true","category":"section"},{"location":"manual-initial-guess.html#prints-something-like:","page":"Initial guesses","title":"prints something like:","text":"","category":"section"},{"location":"manual-initial-guess.html#(q-t-sin(t),-v-t-1.0,-u-t-t)","page":"Initial guesses","title":"(q = t -> sin(t), v = t -> 1.0, u = t -> t)","text":"\nThis does **not** change the semantics of the macro and is primarily intended\nfor interactive experimentation.\n\n---\n\n## Changing the backend prefix (advanced)\n\nInternally, `@init` uses a configurable prefix to decide which module provides\n`build_initial_guess` and `validate_initial_guess`. By default this is the\n`CTSolvers` module, but the prefix can be changed for advanced use cases:\n\n\njulia oldprefix = CTSolvers.initprefix() CTSolvers.init_prefix!(:MyCustomBackend)\n\n@assert CTSolvers.init_prefix() == :MyCustomBackend","category":"section"},{"location":"manual-initial-guess.html#Restore-the-default-prefix","page":"Initial guesses","title":"Restore the default prefix","text":"CTSolvers.initprefix!(oldprefix) ```\n\nThis is only needed if you want to route the macro expansion to a different backend module exposing the same API as CTSolvers.","category":"section"},{"location":"index.html#CTSolvers","page":"Introduction","title":"CTSolvers","text":"Documentation for CTSolvers.","category":"section"},{"location":"index.html#Reproducibility","page":"Introduction","title":"Reproducibility","text":"_downloads_toml(\".\") # hide\n\n<details style=\"margin-bottom: 0.5em; margin-top: 1em;\"><summary>‚ÑπÔ∏è Version info</summary>\n\nversioninfo() # hide\n\n</details>\n\n<details style=\"margin-bottom: 0.5em;\"><summary>üì¶ Package status</summary>\n\nPkg.status() # hide\n\n</details>\n\n<details style=\"margin-bottom: 0.5em;\"><summary>üìö Complete manifest</summary>\n\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>","category":"section"}]
}
